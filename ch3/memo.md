
.thumb_func は、ARMアセンブリにおいて 「この関数はThumbモードで呼び出されるべき関数である」
.thumb_func をつけると、リンカが関数アドレスの LSB（bit0）を 1 にするように処理します。

.ascii は\0がつかない
.asciz は\0がつく
.で始まるものはディレクティブ

.rept 3
.byte 0, 1, 2
.endr 
は以下と同じ
.byte 0, 1, 2
.byte 0, 1, 2
.byte 0, 1, 2
上は
uint8_t name[] = {0, 1, 2};　みたいなもの


outstr: .fill 255, 1, 0
outstr:	ラベル（このアドレスを outstr という名前で参照）
.fill	領域確保のディレクティブ（データを生成する）
255	繰り返し回数（何個作るか）
1	各要素のサイズ（バイト単位）
0	各要素の初期値


.QUAD 0x1234567887654321
は8byteのデータ(64bit)
.WORD, .LONG, .BYTE, .FILL サイズにあわせて

命令（MOV, LDR, BLなど）	大文字	視認性のため（命令が目立つ）
ディレクティブ（.quad, .word, .textなど）	小文字	GNU系ツールの出力に従う形が多い
ラベル（main:, loop:など）	小文字 or ミックス	プログラマのスタイルに依存

#　ニーモニック

[ARM Cortex-m0+](https://developer.arm.com/documentation/dui0662/b/The-Cortex-M0--Instruction-Set/Instruction-set-summary?lang=en)

### BL(Branch with Link)
関数の呼び出し

### MOV
MOVはフラグが変化されない
MOVSはフラグが変化する0フラグやNの負の値など
xpsr のレジスタ
📌 どっちを使うべき？
条件分岐（BEQ, BMI など）に続けて使いたい場合 → MOVS

単に値を移動したいだけでフラグを汚したくない場合 → MOV


### LSR
右に回った1は0になって左から入ってくる


### ASR
左から入ってくるビットは負の値であれば常に1
正の値であれば、常に0

### ROR
右に1がはみ出れば左から1が、
右に0がはみ出れば左から0が入る
くるくるまわるだけ

### ADC
ADDとCフラグを足す

### CMP
CMP R4, #45
でR4の数値から45を引いて、0になればZフラグに1が入る
負の値になればNフラグが1に

### BEQ
もしZフラグが1のときは BEQで指定されたラベルへジャンプ
そうでなければスルー　if文みたいな

### ORR
論理和

###　BIC
AND NOT　指定ビットをクリア


### STRB
STRB R6, [R1] はR6のレジスタに入っている下位1ByteをR1に入っているメモリ位置に書き込む

STR R6, [R1]	32ビット（4バイト）書き込み（ワード）
STRH R6, [R1]	16ビット（2バイト）書き込み（ハーフワード）
STRB R6, [R1]	8ビット（1バイト）書き込み（バイト）


RP2040の一つのアドレスに1byteのデータが入る

アドレス	データ（バイト）
0x20000000	0x12
0x20000001	0x34
0x20000002	0x56
0x20000003	0x78


### LDM
LDM R1, {R2, R3}

R1 = ベースアドレス（このアドレスからロードを開始）
{R2, R3} = ロード先のレジスタ群
R2 に R1 の指すアドレスからのデータ
R3 に R1 + 4 のアドレスからのデータ（32ビット＝4バイト単位）

IA = Increment After（アドレスを後で増加）ト
! = R1 に書き戻しあり（つまり R1 += 8 になる）
!をつけるとR1のメモリ番地が自動でインクリメント
IAはつけなくても！がついている場合はLDMIAと同じ意味　省略可能である